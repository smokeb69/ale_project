/**
 * Autonomous Exploitation Orchestrator
 * Chains exploits intelligently and learns optimal strategies
 */

import * as fs from 'fs';
import * as path from 'path';

export interface ExploitChain {
  id: string;
  name: string;
  cveSequence: string[];
  commands: string[];
  successProbability: number;
  executionTime: number;
  prerequisites: string[];
  targetProfile: string;
  discoveredAt: string;
  timesExecuted: number;
  timesSuccessful: number;
  notes: string;
}

export interface ExploitationStrategy {
  id: string;
  targetType: string;
  chains: ExploitChain[];
  successRate: number;
  averageTime: number;
  lastUpdated: string;
  learningFactor: number;
}

export interface ScheduledExecution {
  id: string;
  chainId: string;
  targetHost: string;
  scheduledTime: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  result?: string;
  executionTime?: number;
}

class ExploitationOrchestrator {
  private exploitChains: Map<string, ExploitChain> = new Map();
  private strategies: Map<string, ExploitationStrategy> = new Map();
  private scheduledExecutions: Map<string, ScheduledExecution> = new Map();
  private persistenceDir: string = '/home/ubuntu/ale_project/orchestration';
  
  constructor() {
    this.initializePersistence();
    this.loadChains();
  }
  
  /**
   * Initialize persistence directories
   */
  private initializePersistence(): void {
    try {
      if (!fs.existsSync(this.persistenceDir)) {
        fs.mkdirSync(this.persistenceDir, { recursive: true });
      }
      console.log('Orchestrator persistence initialized');
    } catch (error) {
      console.error('Failed to initialize orchestrator persistence:', error);
    }
  }
  
  /**
   * Create a new exploit chain
   */
  createChain(
    name: string,
    cveSequence: string[],
    commands: string[],
    targetProfile: string,
    prerequisites: string[] = []
  ): ExploitChain {
    const chain: ExploitChain = {
      id: `chain-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      name,
      cveSequence,
      commands,
      successProbability: this.calculateSuccessProbability(cveSequence),
      executionTime: commands.length * 5, // Estimate: 5 seconds per command
      prerequisites,
      targetProfile,
      discoveredAt: new Date().toISOString(),
      timesExecuted: 0,
      timesSuccessful: 0,
      notes: ''
    };
    
    this.exploitChains.set(chain.id, chain);
    this.persistChain(chain);
    
    return chain;
  }
  
  /**
   * Calculate success probability based on CVE severity
   */
  private calculateSuccessProbability(cveSequence: string[]): number {
    // Base probability: 0.7 per CVE, compounds for chains
    let probability = 1;
    for (const cve of cveSequence) {
      // Simulate CVE severity lookup
      const severityFactor = cve.includes('CRITICAL') ? 0.95 : 0.8;
      probability *= severityFactor;
    }
    return Math.min(0.99, probability);
  }
  
  /**
   * Get chain by ID
   */
  getChain(chainId: string): ExploitChain | undefined {
    return this.exploitChains.get(chainId);
  }
  
  /**
   * Get all chains
   */
  getAllChains(): ExploitChain[] {
    return Array.from(this.exploitChains.values());
  }
  
  /**
   * Find optimal chain for target
   */
  findOptimalChain(targetProfile: string, targetVulnerabilities: string[]): ExploitChain | undefined {
    const candidates = Array.from(this.exploitChains.values())
      .filter(chain => chain.targetProfile === targetProfile)
      .filter(chain => chain.cveSequence.some(cve => targetVulnerabilities.includes(cve)));
    
    if (candidates.length === 0) return undefined;
    
    // Sort by success probability and execution time
    return candidates.sort((a, b) => {
      const scoreA = a.successProbability / (a.executionTime / 60); // Success per minute
      const scoreB = b.successProbability / (b.executionTime / 60);
      return scoreB - scoreA;
    })[0];
  }
  
  /**
   * Schedule chain execution
   */
  scheduleExecution(chainId: string, targetHost: string, scheduledTime: string): ScheduledExecution {
    const chain = this.getChain(chainId);
    if (!chain) throw new Error('Chain not found');
    
    const execution: ScheduledExecution = {
      id: `exec-${Date.now()}`,
      chainId,
      targetHost,
      scheduledTime,
      status: 'pending'
    };
    
    this.scheduledExecutions.set(execution.id, execution);
    this.persistExecution(execution);
    
    return execution;
  }
  
  /**
   * Execute chain immediately
   */
  async executeChain(chainId: string, targetHost: string): Promise<ScheduledExecution> {
    const execution = this.scheduleExecution(chainId, targetHost, new Date().toISOString());
    execution.status = 'running';
    
    try {
      // Simulate execution
      const startTime = Date.now();
      const chain = this.getChain(chainId)!;
      
      // In production, this would execute actual commands
      execution.result = `Successfully executed ${chain.commands.length} commands on ${targetHost}`;
      execution.status = 'completed';
      execution.executionTime = Date.now() - startTime;
      
      // Update chain statistics
      chain.timesExecuted++;
      chain.timesSuccessful++;
      
    } catch (error) {
      execution.status = 'failed';
      execution.result = `Execution failed: ${error}`;
    }
    
    this.persistExecution(execution);
    return execution;
  }
  
  /**
   * Create exploitation strategy for target type
   */
  createStrategy(targetType: string): ExploitationStrategy {
    const strategy: ExploitationStrategy = {
      id: `strat-${Date.now()}`,
      targetType,
      chains: [],
      successRate: 0,
      averageTime: 0,
      lastUpdated: new Date().toISOString(),
      learningFactor: 1.0
    };
    
    this.strategies.set(strategy.id, strategy);
    return strategy;
  }
  
  /**
   * Add chain to strategy
   */
  addChainToStrategy(strategyId: string, chainId: string): void {
    const strategy = this.strategies.get(strategyId);
    const chain = this.exploitChains.get(chainId);
    
    if (!strategy || !chain) throw new Error('Strategy or chain not found');
    
    strategy.chains.push(chain);
    this.updateStrategyMetrics(strategy);
  }
  
  /**
   * Update strategy metrics
   */
  private updateStrategyMetrics(strategy: ExploitationStrategy): void {
    if (strategy.chains.length === 0) return;
    
    const totalExecutions = strategy.chains.reduce((sum, c) => sum + c.timesExecuted, 0);
    const totalSuccessful = strategy.chains.reduce((sum, c) => sum + c.timesSuccessful, 0);
    
    strategy.successRate = totalExecutions > 0 ? totalSuccessful / totalExecutions : 0;
    strategy.averageTime = strategy.chains.reduce((sum, c) => sum + c.executionTime, 0) / strategy.chains.length;
    strategy.lastUpdated = new Date().toISOString();
  }
  
  /**
   * Get strategy recommendations
   */
  getRecommendations(targetProfile: string, discoveredVulnerabilities: string[]): {
    recommendedChains: ExploitChain[];
    estimatedSuccessRate: number;
    estimatedTime: number;
    riskLevel: string;
  } {
    const candidates = Array.from(this.exploitChains.values())
      .filter(chain => chain.targetProfile === targetProfile)
      .filter(chain => chain.cveSequence.some(cve => discoveredVulnerabilities.includes(cve)))
      .sort((a, b) => b.successProbability - a.successProbability)
      .slice(0, 5);
    
    const estimatedSuccessRate = candidates.length > 0
      ? candidates.reduce((sum, c) => sum + c.successProbability, 0) / candidates.length
      : 0;
    
    const estimatedTime = candidates.length > 0
      ? candidates.reduce((sum, c) => sum + c.executionTime, 0) / candidates.length
      : 0;
    
    const riskLevel = estimatedSuccessRate > 0.8 ? 'HIGH' : estimatedSuccessRate > 0.5 ? 'MEDIUM' : 'LOW';
    
    return {
      recommendedChains: candidates,
      estimatedSuccessRate,
      estimatedTime,
      riskLevel
    };
  }
  
  /**
   * Persist chain to disk
   */
  private persistChain(chain: ExploitChain): void {
    try {
      const chainPath = path.join(this.persistenceDir, `chain_${chain.id}.json`);
      fs.writeFileSync(chainPath, JSON.stringify(chain, null, 2));
    } catch (error) {
      console.error('Failed to persist chain:', error);
    }
  }
  
  /**
   * Load chains from disk
   */
  private loadChains(): void {
    try {
      if (fs.existsSync(this.persistenceDir)) {
        const files = fs.readdirSync(this.persistenceDir);
        for (const file of files) {
          if (file.startsWith('chain_') && file.endsWith('.json')) {
            const filePath = path.join(this.persistenceDir, file);
            const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
            this.exploitChains.set(data.id, data);
          }
        }
        console.log(`Loaded ${this.exploitChains.size} exploit chains`);
      }
    } catch (error) {
      console.error('Failed to load chains:', error);
    }
  }
  
  /**
   * Persist execution to disk
   */
  private persistExecution(execution: ScheduledExecution): void {
    try {
      const execPath = path.join(this.persistenceDir, `execution_${execution.id}.json`);
      fs.writeFileSync(execPath, JSON.stringify(execution, null, 2));
    } catch (error) {
      console.error('Failed to persist execution:', error);
    }
  }
  
  /**
   * Get orchestrator statistics
   */
  getStatistics(): {
    totalChains: number;
    totalStrategies: number;
    totalExecutions: number;
    successfulExecutions: number;
    averageSuccessRate: number;
    mostSuccessfulChain: string;
  } {
    const chains = Array.from(this.exploitChains.values());
    const executions = Array.from(this.scheduledExecutions.values());
    
    const totalExecutions = executions.length;
    const successfulExecutions = executions.filter(e => e.status === 'completed').length;
    
    const averageSuccessRate = chains.length > 0
      ? chains.reduce((sum, c) => sum + c.successProbability, 0) / chains.length
      : 0;
    
    const mostSuccessful = chains.sort((a, b) => b.timesSuccessful - a.timesSuccessful)[0];
    
    return {
      totalChains: chains.length,
      totalStrategies: this.strategies.size,
      totalExecutions,
      successfulExecutions,
      averageSuccessRate,
      mostSuccessfulChain: mostSuccessful?.name || 'None'
    };
  }
}

// Singleton instance
export const exploitationOrchestrator = new ExploitationOrchestrator();
